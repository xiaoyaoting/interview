1.重排
渲染层内的元素布局发生修改，都会导致页面重新排列，比如窗口尺寸发生变化、删除或添加DOM元素以及修改了影响元素盒子大小的CSS属性（如width，height，padding，）

重排由CPU处理的

2.重绘
绘制，即渲染上色，所有对元素的视觉表现属性的修改，都会引发重绘。
重绘由GPU处理的

无论是重排还是重绘，都会阻塞浏览器；要提高网页性能，就要降低重排和重绘的频率和成本，尽可能少的触发重新渲染

优化策略：
1. css属性读写分离： 如果要用js操作样式，尽量先读后写，避免读写交叉进行，一般最好不用js去操作样式。
2. 通过操作class样式属性值： 通过切换class或者使用元素的style.csstext属性去批量操作元素样式.
3. DOM元素离线更新： 使用DocumentFragment。因为 DocumentFragment 不是真实DOM树的一部分，它的变化不会触发 DOM 树的（重新渲染) ，且不会导致性能等问题。
4. 压缩DOM的深度： 一个渲染层内不要有过深的子元素，少用DOM完成页面样式，多使用伪元素。
5. 图片渲染前指定大小： 因为img是内联元素，加载图片后会改变宽高，严重的会导致页面重排，渲染前指定图片大小或让其脱离文档流。
6. 使用GPU加速： 对页面中可能发生大量重排重绘的元素单独触发渲染层，使用GPU分担CPU压力。一般我们会对动画元素采取硬件加速。

通过 Nuxt 插件继续压缩文件大小
压缩图片检查所有图片--小图片替换成 svg , 大图 png，jpg 压缩一下或转成 webp 格式
UI库按需加载